{"version":3,"sources":["tokenBucketLimiter.js"],"names":["TokenBucketLimiter","bucketSize","tokensPerInterval","interval","stopped","tokens","tokensRemovedAt","Date","now","_isStopped","lastDrip","deltaMs","Math","max","tokensToAdd","min","floor","count","Error","dripTokens","tokensNeeded","undefined","ceil","RateLimiter"],"mappings":";;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;IACaA,kB;;;;;AACX,oCAKG;AAAA;;AAAA,QAJDC,UAIC,QAJDA,UAIC;AAAA,QAHDC,iBAGC,QAHDA,iBAGC;AAAA,QAFDC,QAEC,QAFDA,QAEC;AAAA,4BADDC,OACC;AAAA,QADDA,OACC,6BADS,KACT;;AAAA;;AACD,8BAAM;AACJF,MAAAA,iBAAiB,EAAjBA,iBADI;AAEJC,MAAAA,QAAQ,EAARA,QAFI;AAGJC,MAAAA,OAAO,EAAPA;AAHI,KAAN;AAKA,UAAKH,UAAL,GAAkBA,UAAlB,CANC,CAM6B;;AAE9B,UAAKI,MAAL,GAAc,MAAKJ,UAAnB,CARC,CAQ8B;;AAE/B,UAAKK,eAAL,GAAuB,CAACC,IAAI,CAACC,GAAL,EAAD,CAAvB;AAVC;AAWF;;;;WAED,sBAAa;AACX,UAAI,KAAKC,UAAT,EAAqB;AACnB;AACD;;AAED,UAAMD,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAZ;AACA,UAAME,QAAQ,GAAG,KAAKJ,eAAL,CAAqB,CAArB,CAAjB;AACA,UAAIK,OAAO,GAAGC,IAAI,CAACC,GAAL,CAASL,GAAG,GAAGE,QAAf,EAAyB,CAAzB,CAAd;AACA,WAAKJ,eAAL,GAAuB,CAACE,GAAD,CAAvB;AACA,UAAMM,WAAW,GAAGH,OAAO,IAAI,KAAKT,iBAAL,GAAyB,KAAKC,QAAlC,CAA3B;AACA,WAAKE,MAAL,GAAcO,IAAI,CAACG,GAAL,CAAS,KAAKV,MAAL,GAAcS,WAAvB,EAAoC,KAAKb,UAAzC,CAAd;AACA,aAAOW,IAAI,CAACI,KAAL,CAAW,KAAKX,MAAhB,CAAP;AACD;;;WAED,6BAA6B;AAAA,UAAXY,KAAW,uEAAH,CAAG;;AAC3B,UAAIA,KAAK,GAAG,KAAKhB,UAAjB,EAA6B;AAC3B,cAAM,IAAIiB,KAAJ,yBAA2BD,KAA3B,kDAAwE,KAAKhB,UAA7E,EAAN;AACD;;AAED,WAAKkB,UAAL;AACA,UAAIC,YAAY,GAAGH,KAAK,GAAG,KAAKZ,MAAhC;;AAEA,UAAIe,YAAY,IAAI,CAApB,EAAuB;AACrB,eAAO,CAAP;AACD;;AAED,UAAI,KAAKX,UAAT,EAAqB;AACnB,eAAOY,SAAP;AACD;;AAED,aAAOT,IAAI,CAACU,IAAL,CAAUF,YAAY,IAAI,KAAKjB,QAAL,GAAgB,KAAKD,iBAAzB,CAAtB,CAAP;AACD;;;WAED,iBAAQ;AACN,WAAKO,UAAL,GAAkB,KAAlB;AACA,WAAKJ,MAAL,GAAc,KAAKJ,UAAnB;AACA,WAAKK,eAAL,GAAuB,CAACC,IAAI,CAACC,GAAL,EAAD,CAAvB;;AACA;AACD;;;;EAzDqCe,uB","sourcesContent":["import RateLimiter from './rateLimiter.js';\nexport class TokenBucketLimiter extends RateLimiter {\n  constructor({\n    bucketSize,\n    tokensPerInterval,\n    interval,\n    stopped = false\n  }) {\n    super({\n      tokensPerInterval,\n      interval,\n      stopped\n    });\n    this.bucketSize = bucketSize; // we start with the bucket full\n\n    this.tokens = this.bucketSize; // last drip\n\n    this.tokensRemovedAt = [Date.now()];\n  }\n\n  dripTokens() {\n    if (this._isStopped) {\n      return;\n    }\n\n    const now = Date.now();\n    const lastDrip = this.tokensRemovedAt[0];\n    let deltaMs = Math.max(now - lastDrip, 0);\n    this.tokensRemovedAt = [now];\n    const tokensToAdd = deltaMs * (this.tokensPerInterval / this.interval);\n    this.tokens = Math.min(this.tokens + tokensToAdd, this.bucketSize);\n    return Math.floor(this.tokens);\n  }\n\n  getDelayForTokens(count = 1) {\n    if (count > this.bucketSize) {\n      throw new Error(`Cannot supply ${count} tokens at once (max is bucketSize = ${this.bucketSize}`);\n    }\n\n    this.dripTokens();\n    let tokensNeeded = count - this.tokens;\n\n    if (tokensNeeded <= 0) {\n      return 0;\n    }\n\n    if (this._isStopped) {\n      return undefined;\n    }\n\n    return Math.ceil(tokensNeeded * (this.interval / this.tokensPerInterval));\n  }\n\n  reset() {\n    this._isStopped = false;\n    this.tokens = this.bucketSize;\n    this.tokensRemovedAt = [Date.now()];\n    super.reset();\n  }\n\n}"],"file":"tokenBucketLimiter.js"}