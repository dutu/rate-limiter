{"version":3,"sources":["rateLimiter.js"],"names":["RateLimiter","tokensPerInterval","interval","stopped","_isStopped","Error","tokensRemovedAt","awaitingRestart","Set","dripTokens","Math","floor","tokens","count","push","Date","now","Promise","resolve","add","delayMs","getDelayForTokens","setTimeout","awaitTokens","forEach","empty","tryRemoveTokens","getTokens"],"mappings":"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","sourcesContent":["export default class RateLimiter {\n  constructor({\n    tokensPerInterval,\n    interval,\n    stopped\n  }) {\n    this.tokensPerInterval = tokensPerInterval;\n    this._isStopped = stopped;\n\n    if (typeof interval === 'string') {\n      switch (interval) {\n        case 'sec':\n        case 'second':\n          {\n            this.interval = 1000;\n            break;\n          }\n\n        case 'min':\n        case 'minute':\n          {\n            this.interval = 1000 * 60;\n            break;\n          }\n\n        case 'hr':\n        case 'hour':\n          {\n            this.interval = 1000 * 60 * 60;\n            break;\n          }\n\n        case 'day':\n          {\n            this.interval = 1000 * 60 * 60 * 24;\n            break;\n          }\n\n        default:\n          throw new Error('Invalid interval ' + interval);\n      }\n    } else {\n      this.interval = interval;\n    }\n\n    this.tokensRemovedAt = [];\n    this.awaitingRestart = new Set();\n  }\n\n  dripTokens() {\n    throw new Error(`dripTokens() not implemented`);\n  }\n\n  getDelayForTokens() {\n    throw new Error(`getDelayForTokens() not implemented`);\n  }\n\n  getTokens() {\n    this.dripTokens();\n    return Math.floor(this.tokens);\n  }\n\n  tryRemoveTokens(count) {\n    this.dripTokens();\n\n    if (count > this.tokens) {\n      return false;\n    }\n\n    this.tokens -= count;\n    this.tokensRemovedAt.push([Date.now(), count]);\n    return true;\n  }\n\n  async awaitTokens(count = 1) {\n    if (this._isStopped) {\n      await new Promise(resolve => this.awaitingRestart.add(resolve));\n    }\n\n    let delayMs = this.getDelayForTokens(count);\n\n    if (delayMs === 0) {\n      return Math.floor(this.tokens);\n    }\n\n    await new Promise(resolve => setTimeout(() => resolve(), delayMs));\n    return this.awaitTokens(count);\n  }\n\n  reset() {\n    this.awaitingRestart.forEach(resolve => resolve());\n  }\n\n  stop(empty = true) {\n    this._isStopped = true;\n\n    if (empty) {\n      this.tryRemoveTokens(this.getTokens());\n    }\n  }\n\n  start() {\n    this._isStopped = false;\n  }\n\n  get isStopped() {\n    return this._isStopped;\n  }\n\n}"],"file":"rateLimiter.js"}